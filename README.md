# Router-Android

Simple but powerful router for Android. The main goal of the Router is to separate business logic from 
navigation between screens. A screen shouldn’t know how it has been opened and how it should be closed.
It should only know that in this case it has to close or navigate to another screen or send some data as 
the result of its job to the caller of this screen.

## Key parts of the framework:

1. RoutePath - path to a screen (one screen can have several paths)
2. RouteController - a controller that connects a path with a screen and implements routing logic. It creates a View, ViewModel, connects them, creates components for injections, and injects dependencies.
3. Router - conducts routing between screens
4. Chain - sequence of screens
5. Middleware - interceptor of navigations; it can prevent navigation, or replace it with another route, or perform some operations.

## RoutePath

A class that defines a path to the screen. The properties of this class are parameters that you want 
to send to the screen. Use a simple class when the path doesn’t provide any parameters to the screen. 
Use a data class when you want to pass one or more parameters. Avoid passing heavy data like images or 
long arrays through it. It is usually used to pass small portions of data such as IDs or filter parameters.

### Examples
`class MainPath: RoutePath //Simple path

data class StepPath(val step: Int): RoutePath //Path with parameters

data class DialogPath(val title: String = "",
                      val message: String = "",
                      val okBtn: String = "",
                      val cancelBtn: String = ""): RoutePathResult<Boolean>  //Path with parameters that returns Boolean value`

## RouteController

A class marked by the annotation @Route and implementing one of the children of the RouteControllerInterface.
It connects a path with a screen and assembles the screen. Currently supports 4 types of routes:
1. Simple with only fragment as view `RouteController`
2. With only Fragment as View and Dagger injection `RouteControllerC`
3. Fragment as View and ViewModel `RouteControllerVM`
4. Fragment as View and ViewModel and Dagger injection `RouteControllerVMC`

By default this class should be abstract because all its method generated by the framework. You can
override its if you need to do some extra action, for example add something to the Bundle of the Fragment.

### Only fragment

Here is an example of a simple RouteController. The onCreateView method is generated by the framework.

`
class SimplePath: RoutePath

@Route
abstract class SimpleRouteController: RouteController<SimplePath, SimpleFragment>()
`

Here is another example of a simple RouteController. In this case, we implement the onCreateView method to pass the title parameter to the Fragment.

`
data class SimplePath(val title: String): RoutePath

@Route
class SimpleRouteController: RouteController<SimplePath, SimpleFragment>()
{
    override fun onCreateView(path: SimplePath): SimpleFragment =
        SimpleFragment().apply {
            arguments = Bundle().apply {
                putString("TITLE_KEY", path.title)
            }
        }
}`

### Fragment with Dagger injection

Example of RouteControllerC with dependency injection where AppComponent is a Component interface

`
class SimpleComponentPath: RoutePath

@Route
abstract class SimpleComponentRouteController: RouteControllerC<SimpleComponentPath, SimpleComponentFragment, AppComponent>()
`

You free to override methods below to specify your own implementation

`
fun onCreateView(path: Path): V //override to perform your own Fragment creation proccess
fun onInject(component: Any) {} //override to inject dependencies in this RouteController
fun onCreateInjector(path: Path, component: Any): Any //override to create sub component
fun onInject(view: V, component: C) //override to make your own implementation of injection proccess
`

